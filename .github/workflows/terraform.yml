name: Plan/Deploy Production (infra-banco)

on:
  workflow_dispatch:
    inputs:
      action:
        description: "O que executar?"
        required: true
        default: "plan"
        type: choice
        options:
          - plan
          - deploy
      deploy_prod:
        description: "Confirma deploy em produção? (obrigatório para 'deploy')"
        required: true
        default: false
        type: boolean
      environment:
        description: "Ambiente"
        required: true
        default: "prod"
        type: choice
        options:
          - dev
          - staging
          - prod
      ns:
        description: "Namespace/pessoa (ex: grupo19)"
        required: true
        default: "grupo19"
        type: string

permissions:
  contents: read

jobs:
  prod:
    runs-on: ubuntu-latest
    environment: production

    env:
      TF_DIR: .
      STATE_PREFIX: state
      REPO: infra-banco

      # ajuste conforme sua realidade
      STACK_K8S: infra-k8s
      STACK_VPC: infra-k8s # se VPC for separado, troque para infra-vpc

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Safety check (deploy)
        if: ${{ inputs.action == 'deploy' }}
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ inputs.deploy_prod }}" != "true" ]; then
            echo "deploy_prod=false → abortando deploy"
            exit 0
          fi

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Resolve tfvars + project/env/region + state keys
        id: env
        shell: bash
        working-directory: ${{ env.TF_DIR }}
        run: |
          set -euo pipefail

          ENV="${{ inputs.environment }}"
          NS="${{ inputs.ns }}"

          if [ -f "terraform.${ENV}.tfvars" ]; then
            TFVARS="terraform.${ENV}.tfvars"
          elif [ -f "terraform.tfvars" ]; then
            TFVARS="terraform.tfvars"
          elif [ -f "terraform.tfvars.example" ]; then
            TFVARS="terraform.tfvars.example"
          else
            echo "ERROR: no tfvars found (terraform.${ENV}.tfvars / terraform.tfvars / terraform.tfvars.example)."
            exit 1
          fi

          get_tfvar() {
            local key="$1"
            sed -nE 's/^\s*'"$key"'\s*=\s*"([^"]+)".*$/\1/p' "$TFVARS" | head -n1
          }

          PROJECT_NAME="$(get_tfvar project_name)"
          ENV_TFVARS="$(get_tfvar environment)"
          AWS_REGION_TFV="$(get_tfvar aws_region)"

          : "${PROJECT_NAME:=tech-challenge}"
          : "${ENV_TFVARS:=${ENV}}"
          : "${AWS_REGION_TFV:=us-east-1}"

          STATE_KEY="${{ env.STATE_PREFIX }}/${{ env.REPO }}/${ENV_TFVARS}/${NS}/terraform.tfstate"
          VPC_STATE_KEY="${{ env.STATE_PREFIX }}/${{ env.STACK_VPC }}/${ENV_TFVARS}/${NS}/terraform.tfstate"
          K8S_STATE_KEY="${{ env.STATE_PREFIX }}/${{ env.STACK_K8S }}/${ENV_TFVARS}/${NS}/terraform.tfstate"

          echo "tfvars=${TFVARS}" >> "$GITHUB_OUTPUT"
          echo "project_name=${PROJECT_NAME}" >> "$GITHUB_OUTPUT"
          echo "environment=${ENV_TFVARS}" >> "$GITHUB_OUTPUT"
          echo "aws_region=${AWS_REGION_TFV}" >> "$GITHUB_OUTPUT"
          echo "ns=${NS}" >> "$GITHUB_OUTPUT"
          echo "state_key=${STATE_KEY}" >> "$GITHUB_OUTPUT"
          echo "vpc_state_key=${VPC_STATE_KEY}" >> "$GITHUB_OUTPUT"
          echo "k8s_state_key=${K8S_STATE_KEY}" >> "$GITHUB_OUTPUT"

      - name: Discover backend (bucket + lock table) via AWS
        id: backend
        shell: bash
        run: |
          set -euo pipefail

          PROJECT="${{ steps.env.outputs.project_name }}"
          ENVIRONMENT="${{ steps.env.outputs.environment }}"
          REGION="${{ steps.env.outputs.aws_region }}"
          ACCOUNT_ID="$(aws sts get-caller-identity --query Account --output text)"

          PREFIX="${PROJECT}-tfstate-${ACCOUNT_ID}-${REGION}-${ENVIRONMENT}-"

          BUCKET="$(aws s3api list-buckets \
            --query "Buckets[?starts_with(Name, \`${PREFIX}\`)].Name | sort(@) | [-1]" \
            --output text)"

          if [ -z "${BUCKET}" ] || [ "${BUCKET}" = "None" ]; then
            echo "ERROR: Não achei bucket de state com prefixo: ${PREFIX}"
            aws s3api list-buckets --query "Buckets[].Name" --output text | tr '\t' '\n' | grep -E "${PROJECT}-tfstate-${ACCOUNT_ID}-${REGION}-${ENVIRONMENT}" || true
            exit 1
          fi

          LOCK_TABLE="${PROJECT}-terraform-locks-${ACCOUNT_ID}-${REGION}-${ENVIRONMENT}"

          {
            echo "bucket=${BUCKET}"
            echo "lock_table=${LOCK_TABLE}"
          } >> "$GITHUB_OUTPUT"

      - name: Export TF_VAR remote states (VPC + K8s)
        shell: bash
        run: |
          set -euo pipefail
          BUCKET="${{ steps.backend.outputs.bucket }}"
          REGION="${{ steps.env.outputs.aws_region }}"

          echo "TF_VAR_use_remote_state=true" >> "$GITHUB_ENV"

          echo "TF_VAR_vpc_remote_state_bucket=${BUCKET}" >> "$GITHUB_ENV"
          echo "TF_VAR_vpc_remote_state_key=${{ steps.env.outputs.vpc_state_key }}" >> "$GITHUB_ENV"
          echo "TF_VAR_vpc_remote_state_region=${REGION}" >> "$GITHUB_ENV"

          echo "TF_VAR_k8s_remote_state_bucket=${BUCKET}" >> "$GITHUB_ENV"
          echo "TF_VAR_k8s_remote_state_key=${{ steps.env.outputs.k8s_state_key }}" >> "$GITHUB_ENV"
          echo "TF_VAR_k8s_remote_state_region=${REGION}" >> "$GITHUB_ENV"

      - name: Sanity check remote states exist (S3 head-object)
        shell: bash
        run: |
          set -euo pipefail
          BUCKET="${{ steps.backend.outputs.bucket }}"

          echo "Checking VPC state: s3://${BUCKET}/${{ steps.env.outputs.vpc_state_key }}"
          aws s3api head-object --bucket "${BUCKET}" --key "${{ steps.env.outputs.vpc_state_key }}" >/dev/null

          echo "Checking K8s state: s3://${BUCKET}/${{ steps.env.outputs.k8s_state_key }}"
          aws s3api head-object --bucket "${BUCKET}" --key "${{ steps.env.outputs.k8s_state_key }}" >/dev/null

      - name: Terraform init (remote backend)
        shell: bash
        working-directory: ${{ env.TF_DIR }}
        run: |
          set -euo pipefail
          terraform init -input=false -reconfigure \
            -backend-config="bucket=${{ steps.backend.outputs.bucket }}" \
            -backend-config="key=${{ steps.env.outputs.state_key }}" \
            -backend-config="region=${{ steps.env.outputs.aws_region }}" \
            -backend-config="dynamodb_table=${{ steps.backend.outputs.lock_table }}" \
            -backend-config="encrypt=true" \
            -backend-config="use_lockfile=true"

      - name: Terraform validate
        shell: bash
        working-directory: ${{ env.TF_DIR }}
        run: terraform validate -no-color

      - name: "Fail-fast: remote_state k8s must have outputs + expected keys"
        shell: bash
        working-directory: ${{ env.TF_DIR }}
        run: |
          set -euo pipefail

          terraform console -var-file="${{ steps.env.outputs.tfvars }}" <<< 'keys(data.terraform_remote_state.k8s.outputs)' > k8s_outputs_keys.txt || true
          cat k8s_outputs_keys.txt

          if grep -q '^\[\s*\]$' k8s_outputs_keys.txt; then
            echo "ERROR: k8s remote_state outputs is empty. Check k8s_remote_state_key/bucket/region."
            exit 1
          fi

          if ! grep -Eq 'cluster_security_group_id|eks_nodes_sg_id' k8s_outputs_keys.txt; then
            echo "ERROR: Expected outputs not found in k8s state (cluster_security_group_id or eks_nodes_sg_id)."
            exit 1
          fi

      - name: Terraform plan (gera arquivo + texto) - detailed exit codes
        id: plan
        shell: bash
        working-directory: ${{ env.TF_DIR }}
        run: |
          set -euo pipefail

          set +e
          terraform plan \
            -var-file="${{ steps.env.outputs.tfvars }}" \
            -input=false \
            -no-color \
            -detailed-exitcode \
            -out=tfplan
          code=$?
          set -e

          if [ "$code" -eq 1 ]; then
            echo "terraform plan failed (exit 1)"
            exit 1
          elif [ "$code" -eq 2 ]; then
            echo "Plan has changes (exit 2) — continuing"
          else
            echo "Plan has no changes (exit 0)"
          fi

          terraform show -no-color tfplan > tfplan.txt

      - name: Upload plan artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ steps.env.outputs.environment }}-${{ steps.env.outputs.ns }}-${{ env.REPO }}
          path: |
            tfplan
            tfplan.txt
            k8s_outputs_keys.txt

      - name: Terraform apply (deploy)
        if: ${{ inputs.action == 'deploy' }}
        shell: bash
        working-directory: ${{ env.TF_DIR }}
        run: |
          set -euo pipefail
          terraform apply \
            -var-file="${{ steps.env.outputs.tfvars }}" \
            -input=false \
            -auto-approve \
            -no-color
