name: Terraform CI/CD

on:
  pull_request:
    branches: [main, develop]
    paths:
      - "**.tf"
      - "**.tfvars"
      - ".github/workflows/terraform.yml"
  push:
    branches: [main, develop]
    paths:
      - "**.tf"
      - "**.tfvars"
      - ".github/workflows/terraform.yml"
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment"
        required: true
        type: choice
        options: [dev, staging, prod]
      group:
        description: "Grupo / namespace do state (ex: grupo19)"
        required: true
        default: "grupo19"
      mode:
        description: "Mode"
        required: true
        type: choice
        options:
          - plan
          - apply
      adopt_existing:
        description: "Importar (adotar) recursos existentes ANTES do apply? (SOMENTE prod)"
        required: true
        type: choice
        options: ["false", "true"]
        default: "false"

env:
  TF_VERSION: "1.13.0"
  AWS_REGION: "us-east-1"

  # Default group for PR plan (PR não tem inputs)
  TF_GROUP_DEFAULT: "grupo19"

  # ======= ADOPTION DEFAULTS (produção) =======
  ADOPT_VPC_ID_PROD: "vpc-0d6e40297ef06fdaf"
  ADOPT_SG_NAME_PROD: "tech-challenge-rds-sg-prod"
  ADOPT_IAM_ROLE_NAME_PROD: "tech-challenge-rds-enhanced-monitoring-prod"
  ADOPT_PARAM_GROUP_NAME: "tech-challenge-mysql-params"
  ADOPT_DB_SUBNET_GROUP_PROD: "tech-challenge-db-subnet-group-prod"

  ADOPT_SECRET_MASTER: "tech-challenge/rds/mysql/master-credentials"
  ADOPT_SECRET_APP: "tech-challenge/rds/mysql/app-credentials"
  ADOPT_SECRET_MIGRATION: "tech-challenge/rds/mysql/migration-credentials"
  ADOPT_SECRET_ADMIN: "tech-challenge/rds/mysql/admin-credentials"

permissions:
  contents: read
  pull-requests: write

jobs:
  validate:
    name: Validate Terraform
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Terraform fmt (check)
        run: terraform fmt -check -diff -recursive

      - name: Terraform init (no backend)
        run: terraform init -backend=false

      - name: Terraform validate
        run: terraform validate

  plan_pr:
    name: Plan (PR) - matrix
    runs-on: ubuntu-latest
    needs: validate
    if: github.event_name == 'pull_request'
    strategy:
      fail-fast: false
      matrix:
        env: [dev, staging, prod]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform init (S3 + lockfile)
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
            -backend-config="key=infra/${{ env.TF_GROUP_DEFAULT }}/${{ matrix.env }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"

      - name: Terraform plan
        run: |
          terraform plan \
            -var-file=terraform.${{ matrix.env }}.tfvars \
            -no-color | tee tfplan-${{ matrix.env }}.txt
        continue-on-error: true

      - name: Upload plan (txt)
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ matrix.env }}-txt
          path: tfplan-${{ matrix.env }}.txt
          retention-days: 5

      - name: Comment PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const envName = '${{ matrix.env }}';
            const file = `tfplan-${envName}.txt`;
            const plan = fs.existsSync(file) ? fs.readFileSync(file, 'utf8') : 'Plan output not available';

            const body = `#### Terraform Plan - ${envName}
            <details><summary>Show Plan</summary>

            \`\`\`terraform
            ${plan.slice(0, 65000)}
            \`\`\`

            </details>`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body
            });

  deploy:
    name: Deploy - ${{ github.event.inputs.environment }} - ${{ github.event.inputs.mode }} (adopt=${{ github.event.inputs.adopt_existing }})
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    environment:
      name: ${{ github.event.inputs.environment }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check backend inputs (no secret leakage)
        shell: bash
        run: |
          [[ -n "${{ secrets.TERRAFORM_STATE_BUCKET }}" ]] || (echo "TERRAFORM_STATE_BUCKET is EMPTY/MISSING" && exit 1)
          [[ -n "${{ env.AWS_REGION }}" ]] || (echo "AWS_REGION is EMPTY/MISSING" && exit 1)
          [[ -n "${{ github.event.inputs.group }}" ]] || (echo "group input is EMPTY/MISSING" && exit 1)

      - name: Guardrail - adopt only on prod
        if: github.event.inputs.adopt_existing == 'true' && github.event.inputs.environment != 'prod'
        shell: bash
        run: |
          echo "ERROR: adopt_existing=true só é permitido para environment=prod."
          exit 1

      - name: Terraform init (S3 + lockfile)
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
            -backend-config="key=infra/${{ github.event.inputs.group }}/${{ github.event.inputs.environment }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"

      # =======================
      # ADOPT EXISTING (IMPORT) - SOMENTE PROD E QUANDO adopt_existing=true
      # =======================
      - name: Adopt existing resources (terraform import) - prod
        if: github.event.inputs.adopt_existing == 'true' && github.event.inputs.environment == 'prod'
        shell: bash
        run: |
          set -euo pipefail

          tf_import() {
            local addr="$1"
            local id="$2"

            if terraform state show "$addr" >/dev/null 2>&1; then
              echo "Already in state: $addr"
              return 0
            fi

            echo "Importing: $addr <- $id"
            terraform import "$addr" "$id"
          }

          echo "Resolving SG ID by name in VPC..."
          SG_ID=$(aws ec2 describe-security-groups \
            --filters "Name=vpc-id,Values=${{ env.ADOPT_VPC_ID_PROD }}" "Name=group-name,Values=${{ env.ADOPT_SG_NAME_PROD }}" \
            --query "SecurityGroups[0].GroupId" --output text)

          if [[ -z "${SG_ID:-}" || "$SG_ID" == "None" ]]; then
            echo "ERROR: Não consegui resolver SG ID para name=${{ env.ADOPT_SG_NAME_PROD }} na VPC=${{ env.ADOPT_VPC_ID_PROD }}"
            exit 1
          fi

          # Imports (falha se não existir — que é o correto para PROD quando você marcou adopt=true)
          tf_import "aws_security_group.rds" "$SG_ID"
          tf_import "aws_iam_role.rds_enhanced_monitoring" "${{ env.ADOPT_IAM_ROLE_NAME_PROD }}"
          tf_import "aws_db_parameter_group.mysql" "${{ env.ADOPT_PARAM_GROUP_NAME }}"
          tf_import "aws_db_subnet_group.main" "${{ env.ADOPT_DB_SUBNET_GROUP_PROD }}"

          tf_import "aws_secretsmanager_secret.db_master_credentials" "${{ env.ADOPT_SECRET_MASTER }}"
          tf_import "aws_secretsmanager_secret.db_app_credentials" "${{ env.ADOPT_SECRET_APP }}"
          tf_import "aws_secretsmanager_secret.db_migration_credentials" "${{ env.ADOPT_SECRET_MIGRATION }}"
          tf_import "aws_secretsmanager_secret.db_admin_credentials" "${{ env.ADOPT_SECRET_ADMIN }}"

      - name: Terraform plan
        if: github.event.inputs.mode == 'plan'
        run: |
          terraform plan \
            -var-file=terraform.${{ github.event.inputs.environment }}.tfvars \
            -no-color

      - name: Terraform apply
        if: github.event.inputs.mode == 'apply'
        run: |
          terraform apply \
            -var-file=terraform.${{ github.event.inputs.environment }}.tfvars \
            -auto-approve
